---
title: CodeTON Round 3 (Div. 1 + Div. 2)
description: 想要薅点币 , 结果太久没打啥都不会了 , CD都是差一点 , 但是最后的关键部分没处理好
tags:
  - 容斥原理
  - 贪心
---

# CodeTON Round 3 (Div. 1 + Div. 2)

## A. Indirect Sort

### 题目大意

给定一个排列 , 然后你可以进行任意次以下的操作 , 选择三个下标 $1 \le i < j < k \le n$ , 如果 $a_i \gt a_k$ , 把 $a_i$ 替换成 $a_i + a_j$ , 否则交换 $a_j$ 和 $a_k$ . 把数组变成单调不减数组 . 

### 解题思路

猜结论 , 第一个数必须是 `1` .

小小 YY 一下 , 因为上面的交换规则 , 第一个数是 `1` 就可以随便交换 . 如果不是 `1` , 那后续 `1` 只能变大 , 因为 `1`如果是第一个数 , 那么必定是交换后面两个数 . `1` 如果是第二个数 , 只会交换 , `1` 本身还是在数组后面 . 如果 `1` 是第三个数 , 也不会变大 . 也就是说 `1` 一直存在 , 而整个规则只能把数变大 , 那么数组永远不可能有序 . 

### 参考代码

```cpp
int solve() {
    ans = 0;
    cin >> n;
    for(int i = 1; i <= n; ++i) cin >> a[i];
    if (a[1] == 1) cout << "Yes\n";
    else cout << "No\n";
    return 0;
}
```

