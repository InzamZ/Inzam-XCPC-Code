---
title: AtCoder Regular Contest 147
date: 2022-09-06 14:11:00
updated: 2022-09-06 22:31:05
categories:
  - XCPC
  - Atcoder
tags:
  - 数学
  - 贪心
---

# AtCoder Regular Contest 147

## **A - Max Mod Min**

### 题目大意

给定一个数组，每次选出最大数`a[j]`和最小数`a[i]`，然后把最大的数替换成 $a_j \mod a_i$ , 如果是 `0` 那么直接移除 . 重复上述步骤 , 直到数组只剩一个数 . 

### 解题思路

康复训练第一站 , 状态确实不好 , 所以搞了一个高复杂度版本 , 可惜官方没有卡掉的想法 . 使用的是 `multiset` 每次询问最大值最小值然后直接替换就可以了 , 时间复杂度多了一个 `logN` , 因为取模运算得到的数必定小于取模的数 , 所以得到的数一定是最小值 . 于是每次操作都是在数组的头尾进行操作 . 时间复杂度直接是 `O(N)` . 

### 参考代码

#### $O(NLogN)$ 解法

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
#define pii pair<int,int>
#define f(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
#define F(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)
const int maxn = 2e5 + 10;
const int maxb = 1e9+10;
int T = 1, n, m, ans = 0, a[maxn];
multiset<int> s,ss;

int solve() {
    ans = 0;
    cin >> n;
    s.clear();
    ss.clear();
    for(int i = 1; i <= n ;++i)
    {
        cin >> m;
        s.insert(m);
        ss.insert(-m);
    }
    while (s.size() > 1)
    {
        auto imin = s.lower_bound(-1);
        auto imax = ss.lower_bound(-maxb);
        ans++;
        if (-(*imax) % (*imin) != 0)
        {
            s.insert(-(*imax) % (*imin));
            ss.insert(-(-(*imax) % (*imin)));
        }
        s.erase(s.lower_bound(-(*imax)));
        ss.erase(imax);
    }
    cout << ans << endl;
    return 0;
}
int main()
{
#ifdef ONLINE_JUDGE //don't mix cin/scanf, cout/printf!
	cin.tie(0); cout.tie(0);
	ios::sync_with_stdio(0);
#endif
	
    // cin >> T;
    while (T--) {
        // cout << "Case #" << T + 1 << ":" << endl;
        solve();
    }
    return 0;
}
```

#### $O(N)$ 解法

```cpp
int T = 1, n, m, ans = 0, a[maxn];
deque<int> q;

int solve() {
    ans = 0;
    cin >> n;
    for (int i = 1; i <= n ; ++i)
        cin >> a[i];
    sort(a + 1, a + n + 1);
    for (int i = 1; i <= n; ++i)
        q.push_back(a[i]);
    while (q.size() > 1) {
        int imin = q.front(), imax = q.back();
        if (imax % imin)
            q.push_front(imax % imin);
        q.pop_back();
        ++ans;
    }
    cout << ans << endl;
    return 0;
}
```

### B - Swap to Sort

### 题目大意

给一个排列 , 需要你进行以下两种操作 , 使其恢复升序排序 . 两种操作 , 一种是相邻的两个数交换 , 另一种是交换间隔一个数的两个数 . 不要求输出最优解 , 但是必须要使**操作一最少** , 然后总操作数少于 $10^5$ . 

### 解题思路

怎么交换都是够的 , 但是自己看错题了 , 没考虑操作一最少 . 首先一定是奇数在奇数位置 , 偶数在偶数位置 . 那么错位的需要操作一 , 其他是不用的 . 错位的数字必须和错位的数字交换 , 否则新增的错位数字会增加操作一 . 如果都不错位 , 那么按顺序交换复位就好了 . 

### 参考代码

```cpp
int T = 1, n, m, k, ans = 0, a[maxn], b[maxn];
int ansstr[100000][2];

int solve() {
    ans = 0;
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        b[a[i]] = i;
    }
    for (int i = n ; i > 1; --i) {
        if (a[i] % 2 != i % 2) {
            int res = i - 1;
            while (a[res] % 2 != i % 2){
                res -= 2;
            }
            for(;res != i - 1; res += 2)
            {
                int val = a[res];
                ++ans;
                ansstr[ans][0] = 2;
                ansstr[ans][1] = res;
                swap(a[res],a[res+2]);
                b[val] = res+2;
                b[a[res]] = res;
            }
            int val = a[res];
            ++ans;
            ansstr[ans][0] = 1;
            ansstr[ans][1] = res;
            swap(a[res],a[res+1]);
            b[val] = res+1;
            b[a[res]] = res;
        }
    }
    for (int i = n ; i > 1; --i) {
        while (b[i] != i) {
            int val = a[b[i] + 2];
            ans++;
            ansstr[ans][0] = 2;
            ansstr[ans][1] = b[i];
            swap(a[b[i]], a[b[i] + 2]);
            b[val] = b[i];
            b[i] = b[i] + 2;
        }
    }
    cout << ans << '\n';
    for (int i = 1; i <= ans; ++i) {
        if (ansstr[i][0] == 1)
            cout << "A ";
        else
            cout << "B ";
        cout << ansstr[i][1] << '\n';
    }
    return 0;
}
void main() {
#ifdef ONLINE_JUDGE //don't mix cin/scanf, cout/printf!
    cin.tie(0); cout.tie(0);
    ios::sync_with_stdio(0);
#endif
    // cin >> T;
    while (T--) {
        // cout << "Case #" << T + 1 << ":" << endl;
        solve();
    }
}
```

### C - Min Diff Sum

#### 题目大意

你需要在水平轴上放置 `N` 个点 , 每个点有一个范围 , 你需要计算下列式子的最小值 . 
$$
\sum_{i=1}^{n} \sum_{j=i}^{n} \lvert x_i - x_j \rvert
$$

### 解题思路

作者说 , 这道题目不需要什么复杂算法 , 不需要什么前置知识 , 但是一开始就这么想是很难的 . ~~就是说聪明一点就可以写出来 , 众所周知数学推理不是前置知识 .~~

> 打完Codeforces再继续
