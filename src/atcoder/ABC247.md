---
title: AtCoder Beginner Contest 247
tags:
  - 贪心
  - 多项式
  - 动态规划DP
---

# AtCoder Beginner Contest 247

## **A - Move Right**

### 题目大意

给一个长为4的字符串 , 非循环右移 , 左边补0 , 输出字符串 . 

### 参考代码

```cpp
//InzamZ
//
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define pii pair<int,int>
#define FIO std::ios::sync_with_stdio(false);\
            std::cin.tie(0);
#define FFFOUT freopen("./out.txt" , "w", stdout)
#define FFFIN freopen("./in.txt" , "r", stdin)
const int maxn = 5e5 + 10;
const int maxb = 110;
int T = 1, n, ans = 0;
string s;
int main()
{
#ifdef FI
    FFF;
#endif
    FIO;
    // cin >> T;
    while (T--) {
        ans = 0;
        cin >> s;
        cout << '0';
        for (int i = 0; i < s.size() - 1; ++i)
            cout << s[i];
        cout << '\n';
    }
    return 0;
}
```

## **B - Unique Nicknames**

### 题目大意

这道题题意和坑挂了很多人 . 一个人有姓和名 , 现在给`N`个人取昵称 , 要求昵称取姓或者名 , 且不能与其他任意一个人的姓或名一样 . 

### 解题思路

怎么想呢 , 直接判断名和姓有无出现在其他人的名或姓中 . 这其实是对的 , 但是代码实现往往出现问题 . 其实数据很小只有`100` , 暴力完全可以解决 . 我用的是`map`记录每个字符串的出现次数 . 一看没有说明问题 , 但是问题就在一个人姓和名一样的时候 , 姓和名对应的字符串会出现两次 , 但却是合法的 . 需要特判 . 

### 参考代码

```cpp
//InzamZ
//
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define pii pair<int,int>
#define FIO std::ios::sync_with_stdio(false);\
            std::cin.tie(0);
#define FFFOUT freopen("./out.txt" , "w", stdout)
#define FFFIN freopen("./in.txt" , "r", stdin)
const int maxn = 5e5 + 10;
const int maxb = 110;
int T = 1, n, ans = 0;
string s1, s2;
map <string, int >mp;
int main()
{
#ifdef FI
    FFF;
#endif
    FIO;
    // cin >> T;
    while (T--) {
        ans = 1;
        cin >> n;
        mp.clear();
        vector<pair<string, string >>v;
        for (int i = 1; i <= n; ++i) {
            cin >> s1 >> s2;
            mp[s1]++;
            mp[s2]++;
            v.push_back({s1, s2});
        }
        for (int i = 0; i < n; ++i) {
            if (v[i].first == v[i].second && mp[v[i].first] > 2) {
                ans = 0;
                break;
            }
            else if (v[i].first != v[i].second && mp[v[i].first] > 1 && mp[v[i].second] > 1) {
                ans = 0;
                break;
            }
        }
        if (ans)
            cout << "Yes\n";
        else
            cout << "No\n";
    }
    return 0;
}
```

## **C - 1 2 1 3 1 2 1**

### 题目大意

字符串构造 , 初始`s1 = 1` , 随后$s_i = s_{i-1} + i + s_{i-1}$ . 注意这里的`s`是指数组而非字符串 . 最后输出的最后的数组 , 数字之间空格分开 . 

### 关键数据范围

$1 \leq n \leq 16$



### 解题思路

如果是字符串就可以乱写 , 但是不是 . 那我们能不能用字符串先操作最后手动在数字之间加上空格呢 . 可以 , 在$N \leq 9$可以 , 但是二位数出现就会导致无法区分 . 于是我们用二进制思想 , 用字母代替二位数 , 然后输出的时候替换 . 

### 参考代码

```cpp
//InzamZ
//
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define pii pair<int,int>
#define FIO std::ios::sync_with_stdio(false);\
            std::cin.tie(0);
#define FFFOUT freopen("./out.txt" , "w", stdout)
#define FFFIN freopen("./in.txt" , "r", stdin)
const int maxn = 5e5 + 10;
const int maxb = 110;
int T = 1, n, ans = 0;
string tmp[20] = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "17", "18", "19"};
int main()
{
#ifdef FI
    FFF;
#endif
    FIO;
    // cin >> T;
    while (T--) {
        ans = 0;
        cin >> n;
        string s = "1";
        for (int i = 1; i < n; ++i)
            s = s + tmp[i + 1] + s;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] > '9' || s[i] < '0')
                cout << '1' << s[i] - 'a';
            else
                cout << s[i];
            if (i != s.size() - 1)
                cout << ' ';
            else
                cout << '\n';
        }
    }
    return 0;
}
```

## **D - Cylinder**

### 题目大意

有两种操作 , 一个是在队列中插入`c`个值为`x`的小球 . 第二个操作是在队列中取出`c`个球 , 并输出他们的和 . 操作次数`Q`次 . 

### 关键数据范围

$1\leq Q \leq 2e5\\
1 \leq x,c \leq 1e9$

### 解题思路

要用魔法打败魔法 , 也用队列打败队列 . 显然不能单个球插入 , 按照操作插入 . 然后模拟过程就好了 . 

### 参考代码

```cpp
//InzamZ
//
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define pii pair<int,int>
#define FIO std::ios::sync_with_stdio(false);\
            std::cin.tie(0);
#define FFFOUT freopen("./out.txt" , "w", stdout)
#define FFFIN freopen("./in.txt" , "r", stdin)
const int maxn = 5e5 + 10;
const int maxb = 110;
int T = 1, n;
queue<pair<ll, ll>>q;
int main()
{
#ifdef FI
    FFF;
#endif
    FIO;
    // cin >> T;
    while (T--) {
        ll ans = 0;
        cin >> n;
        for (int i = 1; i <= n; ++i) {
            ll op, x, y;
            cin >> op;
            if (op == 1) {
                cin >> x >> y;
                q.push(pair<ll, ll>(x, y));
            }
            else {
                ans = 0;
                cin >> x;
                while (x > 0) {
                    if (q.front().second == x) {
                        ans += q.front().second * q.front().first;
                        q.pop();
                        break;
                    }
                    else if (q.front().second > x) {
                        q.front().second -= x;
                        ans += q.front().first * x;
                        break;
                    }
                    else {
                        x -= q.front().second;
                        ans += q.front().second * q.front().first;
                        q.pop();
                    }
                }
                cout << ans << '\n';
            }
        }
    }
    return 0;
}
```

## **E - Max Min**

### 题目大意

给你一个数组 , 长度为`N`, 还有两个数`x`和`y` . 问有多少个数组的子区间最大值是`x` , 最小值是`y` . 

### 关键数据范围

$N \leq 2e5$

### 解题思路

首先但凡存在 不在区间`(y,x)`之间的数 的区间都是不合法的 , 于是这些数可以把整个数组分割成若干部分 , 剩下的这些部分就是数字满足要求的 , 但是他们的最大值和最小值要满足要求 , 就需要最小值和最大值至少出现一次 . 以下均针对分割后的每一个数组 . 

统计这种问题可以使用滑动窗口(双指针 左指针 l 右指针 r)的思想 . 首先窗口在数组开头 , 长度为`1 `, `l=1 r=1`, 维护`(l,r)`中`x y` 出现的次数, 只要最大值和最小值有一个没出现 , 我们就不断扩大窗口 , 知道最大值最小值都出现至少一次 , 此时`r=q`并计算贡献 . 只要包含这个区间的大区间都是合法的 , `l=1,r>=q` 一定是合法的 . 此时左指针右移`1`位 , 计算以`2`开头的满足条件的区间 . 此时右指针是不用动的 , 因为如果存在更小的`p`使得`(2,p)`合法 , 那么`(1,p)`一定是合法的 , 那么循环不会持续到`q`才停止 . 同理循环就可以算出所有贡献值了 . 

### 参考代码

```cpp
//InzamZ
//
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define pii pair<int,int>
#define FIO std::ios::sync_with_stdio(false);\
            std::cin.tie(0);
#define FFFOUT freopen("./out.txt" , "w", stdout)
#define FFFIN freopen("./in.txt" , "r", stdin)
const int maxn = 5e5 + 10;
const int maxb = 110;
int T = 1, n, x, y;
ll a[maxn], ans = 0;
vector<vector<int>>v;
vector<int>v1;
int main()
{
#ifdef FI
    FFF;
#endif
    FIO;
    // cin >> T;
    while (T--) {
        ans = 0;
        int cnt = 0, l, r;
        v.clear();
        cin >> n >> x >> y;
        for (int i = 1; i <= n; ++i) {
            cin >> a[i];
            if (y <= a[i] && a[i] <= x)
                v1.push_back(a[i]);
            else {
                v.push_back(v1);
                v1.clear();
            }
        }
        if (v1.size() > 0)
            v.push_back(v1);
        for (auto it : v) {
            l = r = 0;
            int len = r - l + 1, cntx = 0, cnty = 0;
            while (l < it.size()) {
                while (r < it.size() && (cntx == 0 || cnty == 0)) {
                    if (it[r] == x)
                        ++cntx;
                    if (it[r] == y)
                        ++cnty;
                    ++r;
                }
                if (cntx && cnty)
                    ans += (it.size() - r + 1);
                if (it[l] == x)
                    --cntx;
                if (it[l] == y)
                    --cnty;
                ++l;
            }
        }
        cout << ans << '\n';
    }
    return 0;
}
```
